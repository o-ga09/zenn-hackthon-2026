# 開発ワークフロー

## Kiroフック自動化

プロジェクトでは実装とドキュメントの同期を保つため、Kiroフック機能を活用している。

### 設定済みフック

#### 実装後ドキュメント更新フック

- **トリガー**: エージェント実行完了時（`agentStop`）
- **機能**: 実装内容に基づいて関連ドキュメントを自動更新
- **対象**:
  - プロジェクトドキュメント（`docs/`）
  - Steeringファイル（`.kiro/steering/`）
  - README.md
  - 技術仕様書・アーキテクチャ図

#### 開発フロー PR作成フック

- **トリガー**: エージェント実行完了時（`agentStop`）
- **機能**: 実装完了後のGitHub PR作成プロセスを自動ガイド
- **対象リポジトリ**: `o-ga09/zenn-hackthon-2026`
- **PRテンプレート**: `.github/pull_request_template.md`による標準化
- **サポート内容**:
  - ブランチ状態の確認
  - コミットベストプラクティスの適用
  - PR作成テンプレートの提供
  - GitHub MCP連携支援

### フック管理

- **設定場所**: `.kiro/hooks/`
- **ファイル形式**: `.kiro.hook` JSON形式
- **管理方法**: Kiro Hook UIまたはコマンドパレット経由

### 開発フロー

1. **ブランチ作成**: mainから機能ブランチを切る（`feature/`, `fix/`, `docs/`等）
2. **実装作業**: 通常通りコード実装
3. **自動トリガー**: エージェント完了時にフック実行
4. **ドキュメント更新**: 関連ドキュメントの自動更新提案
5. **PR作成ガイド**: GitHub MCP連携によるPR作成支援
6. **Steering更新**: 新しい技術・パターン導入時の自動反映

### Git コミットベストプラクティス

#### コミットメッセージ規約

- **1行目**: 50文字以内の簡潔な要約（動詞で開始）
- **2行目**: 空行
- **3行目以降**: 詳細説明（必要に応じて）

#### コミット粒度

- **論理的な単位**: 機能追加、バグ修正、リファクタリングを分離
- **単一責任**: 1つのコミットで1つの変更に集中
- **原子性**: コミット単位で動作する状態を保つ

#### 例

```
feat: Add development workflow automation hook

- エージェント完了時のPR作成ガイド機能を追加
- GitHub MCP連携によるワークフロー自動化
- コミットベストプラクティスの適用支援
```

## PR作成ベストプラクティス

### PRテンプレート活用

- **標準テンプレート**: `.github/pull_request_template.md`を使用
- **必須項目**: 概要、変更内容、テスト方法、影響範囲を記載
- **チェックリスト**: コード品質、ドキュメント、Git、セキュリティの確認

### PR品質管理

- **一貫した構造**: テンプレートによる標準化されたPR構造
- **レビュー効率**: レビュアー向け情報の明確な記載
- **品質確認**: チェックリストによる確実な品質管理

### レビュープロセス

- **必須レビュー**: 全PRでコードレビュー実施
- **動作確認**: 記載された手順での動作確認
- **ドキュメント確認**: 関連ドキュメント更新の確認

## ベストプラクティス

### フック活用

- 実装完了後は必ずドキュメント更新を確認
- 新しい技術スタック導入時はSteeringファイル更新
- 開発規約変更時は関連ドキュメントの一括更新

### ドキュメント管理

- 実装とドキュメントの同期を常に保つ
- Steeringファイルは開発チーム全体の知識ベース
- 新しいパターンやガイドラインは積極的に文書化
- **ドキュメント作成時は命名規約に従う**:
  - 要件・仕様書: `{連番3桁}_{内容}.md`
  - 設計ドキュメント: `{連番3桁}_{設計内容}.md`
  - Steeringファイル: `{機能名}.md` (小文字、ハイフン区切り)

### 効率化

- 繰り返し作業はフック化を検討
- ドキュメント更新の自動化で開発に集中
- チーム知識の蓄積と共有を促進
